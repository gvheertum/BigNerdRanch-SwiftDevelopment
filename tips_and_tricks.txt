Interesting finds and observations:

* IDE
- When you want to view details regarding a var, you can use alt-click (described as option-click in the book), this will show a popout with information about the variable (like the type).
- In the menu Help -> Documentation and API reference you can find details regarding the language and libraries.

* General
- For readability numeric values can be split with a 1000 separator (_) -> 9_001
- Naming conventions seem to prefer lowerCamelCase (e.g. enum values, struct properties) 

* Enumerations
- Enums are not inheriting from any type by default (unlike .net which inherits from int by default)
- Enums funcs are by default immutable, however you can enalbe this by flagging the function as mutating
- Enums can do a whole lot more then we are used to. In Swift they can have functions, but also different values (like when working with shapes)
- Enums can have associated values. These are set through a constructor-like option when creating the value.
- The associated values cannot be read directly from variables (since they are of the enum type)
- Enums can also have recursion (which requires you to flag the enum or at least the recursive bits as inderect), the compiler otherwise needs to allocate enums in your enum without knowing the depth of the enum tree
- Although enum functions can be quite useful, the full recursion I would prefer doing in classes I think

* Struct
- Structs are initialized by StructName(). The new operator cannot be used.
- Struct funcs are by default not allowed to mutate data, like the enums they need to be flagged as mutating

* Classes
- No mandatory access modifiers (public/private/etc needed)
- Functions are overriden by adding an override to the function
- Calls to the parent class are done through super.[call]
- Override of set vars cannot be done with a simple override addition
- Final prevents override (unlike .net where override cannot be done if not virtual abstract), swift seems to always allow override unless otherwise specified (where .NET can use the new when no override is possible as a work around)
- Structs are copied by value, so altering a struct in your class will only alter the working copy of that element and not the "original", in the monster example this makes that the town in the main is having the old number of residents, while the town copy in the monster updates the number in the local town. This also explains why you should not use let x = nullable {} to work with structs, since updating values will update them locally in the temp var, not in the original.
- Structs have static funcs, classes have class funcs (and statics). These funcs are not created for each instance of the class, but are shared. Class funcs can be overriden (override class func ...), as long as they are not flagged as final (or when used static, since static cannot be overriden, so static func is functionally equal to final class func). The class/statics cannot be called on instances of the class since they are part of the type and not the instances.
